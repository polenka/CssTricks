Семинар по верстке.

То, что вы видите — лишь дидактический материал, учебное пособие. Не следует его воспринимать, как эталонный вариант. Уч. Пособие по материаловедению не обязательно может быть напечатано на лучшей бумаге хорошими чернилами.

ЧАСТЬ 1  - Теория.

UX – User Experience – воспроизвести привычное пользователю поведение веб-приложения, то, что укоренилось от посещения других сайтов в прошлом (курсор палец на ссылке, основная навигация сверху, ссылки в футере). Юзабилити. В то же время учесть психологический момент, ожидания основной ЦА, пользовательской аудитории ( 75-летнего ожидания будут иными, чем у 7-летнего).

UI – User Interface – то, что пользователь видит, заходя на сайт. Внешний вид должен соответствовать тематике, задачам сайта.

HTML5.

Section - Представляет блок, который служит для группировки взаимосвязанных объектов или для разделения текста на разделы. Как правило содержит заголовок.  В Друпале, регионы тегом section делать можно. Кусок текста контент топ, контент боттом. В теме Омега — section – это контент.

Может показаться, что <section> — это современная замена <div>. Но это не так. Вот несколько правил, которые помогут в большинстве случаев определить, когда не следует применять <section>:
•	если требуется контейнер только для оформления или привязки скриптов (для этого применяй <div>);
•	если по смыслу больше подходит <article>, <aside>, <nav>, <header>, <footer>;
•	если блок в начале не имеет естественного заголовка.
Article - <article> — это частный случай <section>. В Друпале в нутри ноды — артикл. Как правило, это основная единица контента.

Header  -Элемент не ограничивается применением только для шапки сайта: <section>, <article>, <aside> и думаю даже <nav> (в особо извращенных случаях) так же могут содержать <header>

Следует помнить, что <header> служит для группировки элементов заголовка. Если у статьи есть только название, тогда <header> будет излишеством:
<article>
	<header>
		<h1>Заголовок статьи</h1>
	</header>
	[контент статьи]
</article>
В таком случае достаточно одного элемента заголовка <h1>:
<article>
	<h1>Заголовок статьи</h1>
	[контент статьи]
</article>
 Footer - применение <footer> не ограничивается только подвалом сайта, он так же может относится к любой секции (разделу) на странице.   Но исторически именно так сложилось.

Nav – основная навигация.

Заботой HTML5 является не только сокращение кода разметки (хотя в итоге оно так и получается). Он так же определяет ряд новых семантических тегов. Спецификацией HTML5 определены следующие новые элементы:
<section>
Представляет общий раздел документа или приложения. Это тематическая группировка контента, который, как правило, содержит заголовок. Примерами применения <section> могут быть пронумерованные разделы диссертации или диалоговые окна с вкладками. Главную страницу можно разбить на несколько <section>. Например, введение, новости и контактная информация.
<nav>
Этот элемент представляет блок на странице с ссылками на другие страницы или какие-то части текущей. Другими словами — это навигационный блок. Не все группы ссылок следует заключать в элемент <nav> — подходят только основные навигационные блоки. Т.е. дублирующие ссылки основной навигации в подвале заключить в <nav> будет ошибкой. Элемента <footer> будет достаточно самого по себе, а <nav> в большинстве случаев будет лишним.
<article>
Это элемент обозначает автономную часть страницы, документа, приложения или сайта, которая способна работать самостоятельно и ее можно использовать повторно. Это может быть сообщение на форуме, статья в журнале, запись в блоге, комментарий пользователя, интерактивный виджет или гаджет и любые другие независимые элементы страницы.
<aside>
Этот элемент обозначает, что данный блок имеет косвенное отношение к основному содержимому и может быть рассмотрен отдельно от него. Такие блоки в типографии часто представлены в виде боковой панели. Этот элемент может быть использован для типографических эффектов, например, чтобы вынести цитаты в сторону, для рекламных блоков или блоков навигации.
<hgroup>
Элемент представляет заголовок раздела. Служит для группировки элементов h1-h6 когда заголовок многоуровневый. Например, когда помимо основного заголовка есть подзаголовок или альтернативный заголовок, или, возможно, слоган.
<header>
Элемент представляет собой группу вступительных или навигационных средств. <header> обычно содержит элементы заголовков (h1-h6, hgroup), но не обязательно. Он так же может быть контейнером для таблиц, форм поиска или логотипа.
<footer>
Элемент <footer> выступает в роли подвала (колонтитула) для ближайшего предка (в случае, если таковой есть и он является секционным блоком: article, aside, nav, section) или корневого элемента. Footer обычно содержит информацию о секции: кто автор, ссылки на связанные документы, авторские права и тому подобное. Footer не обязательно может быть в конце секции, где обычно мы его размещаем. Когда подвал содержит целые разделы, все они воспринимаются как дополнительная информация, приложения к основному содержимому.
<time>
Служит для обозначения времени или даты на странице.
<mark>
Служит для выделения текста в документе по каким-то критериям.
Я знаю, что тебе хотелось бы уже сейчас начать использовать эти элементы. Но не так все просто, надо сперва глубже разобраться в этой теме.
Новые возможности формы -
Плейсхолдер

<form>
	<input name="q" placeholder="Search Bookmarks and History">
	<input type="submit" value="Search">
</form>

<input type="email">
<input type="url" />

<form novalidate>

Семантика кода. - Например, тег <p> — это абзац, и не стоит им размечать строки веб форм. А <b> — это просто выделение текста жирным и это никак не заголовок.  Dl, dt, dd, fieldset, программисты очень любят запихнуть что-нибудь

Друпал крайне несамантичен.

Семантический код для пользователей
Повышает доступность информации на сайте. В первую очередь это имеет значение для альтернативных агентов таких как:
•	семантический код напрямую влияет на объем HTML кода. Меньше кода —> легче страницы —> быстрей грузятся, меньше требуется оперативной памяти на стороне пользователя, меньше трафика, меньший объем баз данных. Сайт становиться быстрей и менее затратным.
•	голосовые браузеры для которых важны теги и их атрибуты, чтобы произнести правильно и с нужной интонацией содержимое, или наоборот не произнести лишнего.
•	мобильные устройства которые не на полную мощь поддерживают CSS и поэтому ориентируются в основном на HTML код, отображая его на экране согласно используемым тегам.
•	устройства печати даже без дополнительного CSS напечатают информацию качественней (ближе к дизайну), а создание идеальной версии для печати превратится в несколько легких манипуляций с CSS.
•	к тому же существуют устройства и плагины, которые позволяют быстро перемещаться по документу — например, по заголовкам у Opera.

Font-family: "Helvetica Neue","Helvetica",Helvetica,Arial,sans-serif;


 
Этим постом я планирую начать серию статей о багах IE и возможных вариантах их исправления. Цикл статей решил написать в первую очередь для себя, дабы как-то систематизировать и сохранить свои знания, но я надеюсь, что он будет полезен как новичкам так и опытным верстальщикам.

Первым постом хочу затронуть одно из фундаментальных понятий при исправлении багов IE — hasLayout.
Что такое hasLayout?

В движке рендеринга IE каждый элемент, по сути, не отвечает за свое расположение. Расположение элемента зависит лишь от его положения в исходном коде и расположения в нормальном потоке. При этом, все дочерние элементы некоторго блока-контейнера располагаются, на самом деле, не относительно своего непосредственного родителя, а в зависимости от наиболее близкого предка имеющего «layout».

hasLayout это проприетарное свойство IE, которое определяет имеет ли элемент «layout» т.е. то, как элемент располагается в потоке, его размеры, позиционирование, реакцию на события и влияние на другие элементы.

HTML элементы, которые по умолчанию имеют «layout» (hasLayout = true): <html>, <body>, <table>, <tr>, <td>, <th>, <img>, <input>, <button>, <textarea>, <select>, <fieldset>, <legend>, <hr>, <iframe>, <embed>, <object>, <applet>, <marquee>.

Свойство hasLayout в IE нельзя напрямую установить, но на его наличие можно косвенно влиять различными значениями некоторых css свойств. Следующие значения перечисленных свойств дают элементу «layout» (hasLayout = true):
•	position: absolute
•	float: left или right
•	height, width: любое значение кроме auto
•	display: inline-block
•	zoom: любое значение кроме normal (невалидное свойство)
•	writing-mode: tb-rl
•	overflow, overflow-x, overflow-y: auto|scroll|hidden (только в IE7)
•	position: fixed (только в IE7)
•	min-width, min-height: любое значение (только в IE7)
•	max-width, max-height: любое значение кроме none (только в IE7)

Чтобы скинуть hasLayout нужно указать значение отличное от перечисленных выше (например: width: auto или float: none).
 
 

ПРОБОВАТЬ!
Перед второй частью — что такое блочный, строчный (строковый), инлайн-блочный элемент. Нормальный поток, плавающий элемент.

Блочный элемент имеет высоту, ширину.  Стремится принять ширину родителя и высоту потомка. Инлайн не имеет высоты, вертикальных маргинов и паддингов. Кроме img

Когда блочный элемент обтекает флоат, текст не налезет, но если есть блок и кратинка — да.
Инлайн элемент с текстом НЕ ОБТЕЧЕТ, он просто уместится в свободное за флоатом место строки. Но на сам флоат не зайдет. Инлайн-блок и не обтечет, и не сделает попытки уместиться в свободную часть строки, если он туда не входит по ширине.
Маргины у флоата с нефлоатом не складываются.
Блок с обтеканием, чтобы не обтекал — клеар, но тогда он маргином не отталкнется. Будет работать только маргин флоата. Чтобы отталкнуть склеарный элемент — паддинг у него.

Вертикальные маргины! Они могут складываться с другими элементами. Это важно особенно для заголовков и абзацев.

Например, это можно использовать как на HM, чтобы выстроить все в одну линию.

Свойство box-sizing определяет, будет ли размер элемента включать только контент (по умолчанию) или контент, внутренние отступы и границы.
Допустимые значения
•	content-box — поведение ширины и высоты как в спецификации CSS 2.1. Внутренние отступы и границы элемента находятся за пределами указанной ширины и высоты.
•	border-box —внутренние отступы и границы элемента находятся в пределах указанной ширины и высоты. Ширина и высота непосредственно контента определяется вычитанием из указанного в свойстве значения  границ и внутренних отступов элемента. (или padding-box) C вендорными префиксами.
•	inherit — наследует значение от родителя.
В ие8, думаю, будут проблемы с минимальной высотой и шириной.





Если что-то стоит неровно, не подгонять на глазок, а точно знать, на какое кол-во пикселей, куда двигать. Вот я не люблю, когда я что-то сделала, оно наладилось, а я не поняла, почему. Работает и ладно - это не тот стиль. Слишком много систем и браузеров. Если это неверно с точки зрения стандартов, то это может где-то сломаться. Но кое-что на глаз - переключение окошек, глаз уловит небольшие изменения.

	

У всех сложно позиционируемых колонок, колонок в процентах, по возможности бордеры – это редко – и паддинги (чаще) – у внутренних элементов. <div class="inner">

Ширина нового родителя  (80) – 100%
Ширина колонки, в которую нужно поместить (левая 20%) 20% - x (ширина внутренней колонки, которую нужно поместить)

80% - 100%
20% - х

Три колонки одинаковой высоты способом Чикуенка - верстка осложняется тем, что первые две колонки должны быть в общей рамке, между которыми есть вертикальный разделитель.


Кнопки (ссылка и сабмит) – вебкиты поймут первый вариант, но мозилла нет. Ие7 – ряд свойств (уменьшить line-height;)

- a:hover span (что надо прописывать hover у ссылки) - в инпутах и ссылках
- position: absolute - top: 100%;

BOX-SHADOW: Значения свойства задает список теней, каждая из которых имеет 2 значения смещения по осям, радиус размывания(необязательный параметр), радиус распространения (необязательный параметр) и цвет. Порядок значений строго определен.


ЧИКУЕНОК.

Обращаем внимание на размеры колонок: первая 25%, вторая 50%. То есть вторая колонка ровно в 2 раза больше первой. Соответственно, если первому — внешнему — контейнеру мы задаим ширину в 25%, а второму — внутреннему — 200% (две ширины внешнего контейнера, что будет соответствовать 50% относительной всей страницы) и сместим его на ширину контейнера вправо, мы получим подобие того, чего хотим добиться:

Осталось разобраться с текстовыми колонками. У нас появился новый контейнер, от которого рассчитываются размеры колонок. Так как левая колонка должна быть шириной в 25% от страницы, а ширина внутреннего контейнера равна 50% от страницы, то новая ширина колонки будет равна 50% (50% × 0.5 = 25%). Сама колонка не должна влиять на ширину, но все еще должна быть в потоке, поэтому подавляем влияние ширины колонки на поток с помощью margin-right:-100%, а сам элемент смещаем влево на половину ширины контейнера, то есть на 50%. Получаем именно то, что нам нужно:

<style type="text/css">
.col-wrap1 {
width:25%;
background:blue;
}
 
.col-wrap2 {
width:200%;
margin-right:-100%; /* чтобы IE6 не раздвигал контейнер */
position:relative;
left: 100%;
background:red;
}
 
.col1 {
float:left;
width:50%;
margin-right:-100%;
position:relative;
left:-50%;
}
 
.clear {
clear:both;
font-size:0;
overflow:hidden; /* тройной презерватив для IE */
}
</style>
<div class="col-wrap1">
<div class="col-wrap2">
<div class="col1">left column</div>
<div class="col2">center column</div>
<div class="clear"></div>
</div>
</div>


Трехколончатый макет Майка.

.column .sidebar_left_two {
    float: left;
    margin-left: 0;
    margin-right: -20%;
    width: 20%;
	height: 400px;
	background-color: #1472A3;
}

.column .center_column_two {
    margin-left: 20%; /*Или 0, если нет левой колонки*/
    margin-right: -80%; /*Или 100%, если нет правой колонки*/
    width: 60%;
	float: left;
	height: 400px;
	background-color: #999999;
}

.column .sidebar_right_two {
    float: left;
    margin-left: 80%;
    margin-right: -100%;
    width: 20%;
	height: 400px;
	background-color: #60AE01;
}
